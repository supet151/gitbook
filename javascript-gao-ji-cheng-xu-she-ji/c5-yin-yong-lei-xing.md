# C5-引用类型

引用类型的值\(对象\)是引用类型的一个实例。在ES中，引用类型是一种数据结构。 使用类称呼引用类型并不妥当。

对象是某个特定引用类型的实例。新对象是使用new操作符后跟一个构造函数来创建的。该函数出于创建新对象的目的而定义的。

```text
var person=new Object();
```

## Object类型

大多数引用类型值都是Object类型的实例。 创建Object实例：

* 使用new操作符后跟Object构造函数
* 另一种是使用**对象字面量**表示法。`{`表示字面量的开始，`}`表示字面量的结束

    使用字面量表示法的属性可以为字符串也可以不为字符串。

对象字面量语法，推荐只在考虑对象属性名的可读性时使用。 使用字面量定义对象实际上不会调用Object构造函数。

可以使用对象字面量封装多个可选参数。

访问对象属性可以使用：

* 点表示法
* 方括号表示法

两者功能相同，方括号语法的主要优点是可以通过变量来访问属性。

如果属性名包含会导致语法错误的字符，或者属性名使用的是关键字或者保留字，也可以使用方括号表示法。

```text
person["first name"]="jack";
```

**通常建议使用点表示法访问属性。**

## Array类型

ES的Array类型对其中的数据类型没有限制。 而且数组大小可以动态调整，可以随着数据的添加自动增长以容纳新增数据。

创建数组的基本方式：

* 使用Array `new Array();`
  * 可以向函数`Array()`传递参数：数组长度`length`；
  * 可以向函数传递数组中应该包含的项，以`,`分隔

      使用`Array()`构造函数可以省略new操作符。
* 使用数组字面量表示法。 使用数组字面量表示法时，也不会调用Array构造函数

读取和设置数组的值，使用方括号并提供相应值的基于0的数字索引。

数组的length属性不只是只读的，通过设置这个属性，可以改变数组的项。 数组末尾的新项永远是`array[length]`。

### 检测数组

* 使用instanceof操作符得到结果，如果存在多个全局执行环境，就会存在多个不同版本的Array\(\)构造函数，两个环境中的Array\(\)不同。
* Array.isArray\(\)方法，参数为希望判断的数组

### 转换方法

调用数组的`toString()`方法会返回由数组中的每个值的字符串形式拼接而成的一个以逗号分隔的字符串。为了创建字符串会调用数组每一项的toString\(\)方法。 `valueOf()`返回还是数组。 `alert(array)`也会在后台调用`toString()`。 `toLocaleString()`方法也经常会返回与前面两者相同的值，会调用每一项的toLoacleString方法。 使用`join()`可以使用不同的分隔符来构建这个字符串，它会接受一个字符串参数作为分隔符，返回包含所有数组项的字符串。该函数的默认参数为`,`。

在以上函数的返回值中，数组项为null\|\|undefined时的返回值为空字符串。

### 栈方法

* push方法可以接受任意数量的参数，把他们逐个添加到数组末尾，并返回修改后的数组长度。
* pop方法则从数组末尾移除最后一项，减少数组的length值，然后返回移除的项。

### 队列方法

* shift\(\)方法从数组前端取得项，同时数组长度减1
* unshift\(\)方法在数组前端添加任意个项并返回新的数组的长度。

### 重排序方法

数组中已经存在两个可以直接用来重排序的方法：

* `reverse()`将会反转数组项的顺序
* `sort()`在默认情况下按照升序排列数组项，sort\(\)会调用每个数组项的toString\(\)方法，然后比较得到的字符串，即使数组项为数值也会转化为字符串比较。

    sort\(\)也可以接受一个比较函数作为参数来进行自定义排序。

    比较函数接受两个参数，如果第一个参数应该位于第二个之后返回一个负数，相等则返回0，反之返回整数。

    对于数值类型的升序排列，可以调用：

  ```text
    function compare(v1,v2){
        return v2-v1;
    }
  ```

### 操作方法

`concat()`可以基于当前数组中的所有项创建一个新数组，将接受到的参数添加到数组副本的末尾，返回新构建的数组。 如果没有给函数传递参数，将会只是简单地创建一个数组的副本。

`slice`方法能够基于当前数组中的一个或者多个项创建一个新数组。 它可以接受一个或者两个参数。 只有一个参数时，`slice()`返回从该参数指定位置开始到当前数组末尾的所有项。 如果有两个参数，该方法返回起始和结束位置之间的项，但是不包括结束位置的项。 如果`slice()`有一个负数，则用数组长度加上该数来确定相应的位置。 如果结束位置小于起始位置，则返回空数组。

`splice`方法 接受参数:操作的第一项，删除的项数，添加的数组项1，添加的数组项2... 该方法会始终返回一个数组，该数组包含从原始数组中删除的项，没有删除项返回空数组。

### 位置方法

`indexOf`和`lastIndexOf`。 两个方法接受两个参数，要查找的项和表示查找起点位置的索引，查找时项必须全等。

前一个方法从数组开头向后查找。 后一个方法从数组末尾开始向前查找。

两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回-1。

### 迭代方法

每个迭代方法都会接受两个参数：要在每一项上运行的函数和\(可选值\)运行该函数的作用域对象：影响this的值。 传入这些方法的函数接受三个参数： 数组项的值、该项在数组中的位置和数组对象本身。

* `every()`对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true
* `some()`对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。
* `filter()`对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。
* `forEach()`对数组中的每一项运行给定函数。该方法没有返回值。
* `map()`对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。

### 缩小方法

缩小数组的方法 `reduce`&`reduceRight()`这两个方法会迭代数组的所有项，构建一个最终的返回值。 `reduce()`从数组的第一项开始，逐个遍历到最后。 `reduceRight()`从数组的最后一项开始，向前遍历到第一项。

两个方法接受两个参数：一个在每一项上调用的callback函数和\(可选的\)作为缩小基础的初始值\(作为第一次调用 callback函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错\); 传给两者的函数接收四个参数:前一个值，当前值，项的索引和数组对象。 这个函数返回的任何值都会作为第一个参数自动传给下一项。 第一次迭代发生在数组的第二项，所以第一个参数为数组的第一项。

`reduceRight`的作用相似，但是遍历方向相反。

### Date类型

Date类型使用自UTC\(国际协调时\)1970,1,1开始经过的毫秒数保存日期。在使用这种数据存储格式的条件下，Date类型保存的日期能够精确到之后的285616年。

创建一个日期对象：

```text
var now=new Date();
```

构造函数不传递参数，新创建的对象**自动获得当前日期和时间**。

传入表示日期的毫秒数可以根据特定的时间创建Date\(\);

`Date.parse()`方法接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应的日期的毫秒数。 日期格式没有进行强制规定，可以为：

* "m/d/y":6/13/2004
* "Mname d,y":January 12,2004
* "星期几 月名 d y h:m:s 时区":Tue May 25 2004 00:00:00 GMT-0700
* ISO 8601扩展格式 YYYY-MM-DDTHH:mm:ss.sssZ:2004-05-25T00:00:00

如果传入Date.parse\(\)的字符串不能表示日期，它会返回NaN。 如果直接表示日期的字符串传递给Date\(\)，也会在后台调用Date.parse\(\);

_浏览器会倾向于将超出范围的值替换成当前的值输出。_

`Date.UTC()`返回表示日期的毫秒数，但是它与Date.parse\(\)在构建时使用不同的信息。 Date.UTC\(\)的参数分别是年份、基于0的月份、天、h,m,s,ms，在这些参数中，只有年和月是必须的。 天数默认值为1，其他默认为0。

Date\(\)也会在后台调用Date.UTC\(\),但是调用该函数时，日期和时间都**基于本地时区**而非GMT。不过，Date构造函数接收的参数仍然与Date.UTC\(\)相同。

因此如果第一个参数是数值，Date\(\)构造函数会假设该值是日期中的年份，而第二个参数是月份。

```text
var newtime=new Date(2000,0);
```

ES5添加了`Date.now()`方法，返回表示调用这个方法时的日期和时间的毫秒数，该方法可以用来进行代码性能分析。

### 继承的方法

`toLocalString()`会按照与浏览器设置的地区相适应的格式返回日期和时间。这大致意味着时间格式包含AM&PM,但是不包含时区信息 `toString()`通常返回带有时区信息的日期和时间\(小时的范围为0-23\)。

`valueOf()`不返回字符串，返回日期的毫秒表示。可以方便用比较操作符来比较日期值。

### 日期格式化方法

专门用于将日期格式化为字符串的方法：

* `toDateString()`以特定于实现的格式显示星期几、月、日和年
* `toTimeString()`以特定于实现的格式显示时、分、秒和时区
* `toLocaleDateString()`以特定于实现地区的格式显示星期几、月、日和年
* `toLocaleTimeString()`以特定于实现地区的格式显示时、分、秒
* `toUTCString()`以特定于实现的格式完整的UTC日期

UTC日期是指在没有时区偏差情况下\(当前的GMT时间\)的日期值。

### 日期/时间组件方法

有几个常用的：

* `getFullYear()`取得四位数得年份
* `getMonth()`返回日期中的月份，以0作为基数
* `getDate()`返回月份中的天数，1-31
* `getDay()`返回日期中的星期0-6\(日-六\)
* `getHours()`
* `getMinutes()`
* `getSeconds()`
* `getMilliseconds()`

## Function类型

函数通常是使用函数声明语法定义的，如：

```text
function sum(num1,num2){
    return num1+num2;
}
//equal函数表达式
var sum=function(num1,num2){
    return num1+num2;
}
```

函数名仅仅是一个指向函数的指针，一个函数可能有多个名字\(指针\)。

### 没有重载

ES的函数没有重载概念。 同名函数会被最后一次声明的函数覆盖。

### 函数声明与函数表达式

解析器在向执行环境中加载数据时，解析器会率先读取**函数声明**，并使其在执行任何代码之前可用\(函数声明提升\); **函数表达式**必须等到解析器执行到所在代码行才会被真正解释执行。 可以同时使用函数声明与函数表达式，不过真的有这个必要吗？

### 作为值的函数

可以把函数作为一个值处理，即函数也可以返回一个函数，

### 函数内部属性

`arugments`是一个类数组对象，包含着传入函数中的所有参数。它有一个属性`callee`，该属性是一个指针，指向拥有这个`arguments`对象的函数。

使用`arguments.callee`可以调用拥有`arguments`的函数，使用这种写法能够接触函数体内的代码与函数名的耦合状态。

`this`引用函数据以执行的环境对象。

`caller`属性中保存着调用当前函数的函数的引用，如果在全局作用域中调用当前函数，值为`null`。

_严格模式下，访问`arguments.callee`会导致错误。_ _且ES5定义了`arguments.caller`,在严格模式下也会导致错误，非严格模式下，其值恒为_undefined。这一举动旨在加强代码的安全性。 __严格模式下，不能为函数的`caller`赋值。\*

### 函数属性和方法

ES中函数是对象，每个函数都包含两个属性：`length`,`prototype`。 `length`属性表示函数希望接收的命名参数的个数。

对于ES中的引用类型而言，`prototype`保存它们所有实例方法的真正所在。 ES5中,该属性不可枚举。

每个函数都包含两个继承来的方法：`apply()`&`call()`； 这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内的this对象的值。

`apply`可以接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。**第二个参数可以是Array实例，也可以是arguments对象。**

在严格模式下，未定义环境对象而调用函数，this值不会转型为window，除非明确把函数添加到某个对象或者调用apply\(\)\|\|call\(\)，否则this值将会是undefined。

`call`方法和`apply()`作用相同，区别仅在于接收参数方式不同。 `call`接收参数，第一个为this,但是其余参数都作为参数直接传递函数。 即使用`call()`，传递的参数必须逐个列举出来。

`apply()`&`call()`的强大之处在于扩充函数的作用域。这样，对象和方法不需要耦合。

ES5提供了`bind()`。这个方法会创建一个函数的实例，其this值会被会被绑定到传给bind\(\)函数的值。

`toLocalString()`&`toString()`&`valueOf()`始终返回函数代码。

## 基本包装类型

在每次读取一个基本类型值时，后台会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法操作数据。

```text
var s1="msg";
var s2=s1.substring(1);
```

在上面代码的第二行访问s1时，访问过程处于读取模式，从内存中读取字符串的值。

在读取模式访问字符串时，后台会：

* 创建String类型的一个实例；
* 在实例上调用指定的方法；
* 销毁实例

可以认为是：

```text
var s1=new String("msg");
var s2=s1.substring(1);
s1=null;
```

经过这样处理，基本的字符串值就变得和对象一样了，可以拥有方法。该步骤也适用于Boolean和Number类型。

引用类型和基本包装类型的主要区别是对象的生存期。 使用new创建的引用类型的实例在执行流离开当前作用域时一直保存在内存中。 自动创建的基本包装类型的对象，只存在于一行代码的执行瞬间，然后会被立刻销毁。 **所以我们不能在运行时为基本类型值添加属性和方法。**

应该在绝对需要的时候显示调用创建基本包装类型的对象。

**Object\(\)会根据传入值的类型返回相应基本包装类型的实例。**

注意： **使用new调用基本的包装类型的构造函数，如果不含new，就是调用同名的转型函数。** 布尔表达式中，所有的基本包装类型都会被转为true。

### Boolean类型

Boolean类型是与布尔值对应的引用类型。 可以调用`new Boolean(true)`来创建Boolean类型对象。

`valueOf()`返回true/false\(基本类型的布尔型\) `toString()`返回"true"/"false"；

要注意Boolean对象的实际应用：

```text
var falseObj=new Boolean(false);
var result=falseObj&&true;//true;
```

这里Boolean实例被当作对象处理，所以result结果为false;

### Number类型

Number类型是与数字值对应的引用类型。要创建Number对象，可以调用： `new Number(11);`

`valueOf()`返回对象表示的基本类型的数值 `toString()`&`toLocaleString()`返回字符串形式的数值。

可以为`toString()`传递一个表示基数的参数，告知其返回进制。

`toFixed()`按照指定的小数位返回数值的字符串表示，参数为小数位数。通常浏览器支持0-20位小数。

`toExponential()`该方法返回以指数表示法\(e表示法\)表示的数值的字符串形式，它接收参数为输出结果中的小数位数。

`toPrecision()`该方法会返回最合适的格式的字符串，接收一个参数，表示不包括指数部分的数值的所有数字的位数。

### String类型

String类型是字符串的对象包装类型。构建： `new String("this is string");`

`valueOf()`,`toLocaleString()`,`toString()`返回对象所表示的基本字符串值。

`length`属性表示字符串中包含多少个字符，双字节字符也算一个字符。

#### 字符方法

访问特定字符： 两个方法接收一个参数：基于0的字符位置 `charAt()`以单字符字符串的形式返回给定位置的字符 `charCodeAt()`以编码形式返回指定位置字符

在支持的浏览器中，可以使用**方括号加数字索引**访问字符串中的特定字符。

#### 字符串操作方法

`concat()`拼接字符串，其可接收参数为任意。

三个方法返回被操作字符串的一个子字符串，接收一个或者两个参数：第一个参数指定子字符串的开始位置，第二个参数表示到哪里结束。 `slice()`传入负值，负值与字符串长度相加& `substring()`第二个参数指定子字符串最后一个字符后面的位置。传入负值，所有负值变为0 `substr()`第二个参数指定返回字符的个数。传入负值，负的第一个参数加上字符串长度，第二个变为0

如果没有给这些方法传递第二个参数，则将字符串的长度作为结束位置。

`substring()`将会以较小的参数开始，较大的参数结束。

以上方法对于字符串本身没有任何影响。

#### 字符串位置方法

字符串中查找子字符串的方法： `indexOf`&`lastIndexOf` 这两个方法都是从一个字符串中搜索给定的子字符串，然后返回字符串的位置\(没有找到返回-1\)。 前者从字符串的开头向后搜索，后者从字符串末尾向前搜索字符串。

两者可接收第二个参数，表示从字符串中的哪个位置开始搜索。

#### trim\(\)方法

ES5定义了`trim()`方法。这个方法会创建一个字符串的副本，删除前置及后缀所有空格，然后返回结果。 `trimLeft()`和`trimRight()`分别用于删除字符串开头和末尾的空格。

#### 字符串大小写转换方法

`toLowerCase()` `toUpperCase()`

针对特定地区的实现，一般用这组更稳妥 `toLocaleLowerCase()` `toLocaleUpperCase()`

#### 字符串的模式匹配方法

见正则表达式部分

#### localeCompare\(\)

该方法比较两个字符串，并且返回下列值中的一个：

* 字符串在字母表中应该排在字符串参数之前，返回一个负数\(-1\)
* 字符串等于字符串参数，返回0
* 字符串在字母表中应该排在字符串参数之后，则返回一个正数\(1\);

该方法依照所在地区而变化，比如美国区分大小写且大写字母排在小写字母之前。

#### fromCharCode\(\)

该方法的任务是接收一或多个字符编码，然后把他们转换成一个字符串。 可以视为与charCodeAt\(\)执行相反操作。

#### HTML方法

Web浏览器提供商的扩展标准。

## 单体内置对象

由ES实现提供的，不依赖于宿主环境的对象，这些对象在ES程序执行之前就已经存在。

### Global对象

Global对象可以说是ES的一个“兜底对象”。不属于任何其他对象的属性和方法，最终都是它的属性和方法。 **事实上，没有全局变量或者全局函数，所有在全局作用域中定义的属性和函数都是Global对象的属性。**

#### URI编码方法

这两个方法可以对URL进行编码以便发送给浏览器，它们使用特殊的UTF-8编码代替无效字符。 `encodeURI()`对于整个URL编码，不会对本身属于URI的特殊字符进行编码\(`:`,`/`,`?'`,`#`\)。 `encodeURIComponent()`对于URL的一段编码，会对发现的任何非标准字符进行编码

对应的解码方式： `decodeURI()`只能处理`encodeURI()`替换后的编码； `decodeURIComponent()`，能够解码`encodeURIComponent()`处理的字符串。

#### eval\(\)方法

它接收一个参数，即要执行的ES字符串。

当解析器发现调用eval\(\)时，会将传入的参数当作实际的ES语句解析，然后把执行结果插入到原位置。 通过eval\(\)执行的代码被认为是包含该次调用的执行环境的一部分。被执行的代码拥有与当前执行环境相同的作用域链。因此，可以在eval\(\)内部获取外部变量，外部也可以获取内部变量。

eval\(\)中创建的任何变量或者函数都不会提升，因为在解析代码的时候，它们被包含在一个字符串中；他们只在eval\(\)执行的时候创建。

_严格模式下，外部访问不到eval\(\)中创建的任何变量或函数。_

#### Global对象的属性

ES5禁止给undefined,NaN,Infinity赋值，这样会导致错误

#### window对象

Web浏览器将Global作为window的一部分实现。 在全局作用域中声明的所有变量和函数，都成为了window对象的属性。

同时，可以使用代码

```text
var global=function(){
    return this;
}
```

获得Global对象。

### Math对象

该对象是ES为保留数学公式和信息提供的公共位置。

#### Math对象的属性

[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math)

#### min\(\)&max\(\)

`Math.min()` `Math.max()`

使用如下代码取数组最大值最小值

```text
var values=[1,2,3,4,5,6,7];
var max=Math.max.apply(Math,values);
```

把Math对象作为apply\(\)的第一个参数，从而设置this值，再传入数组作为第二个参数。

#### 舍入方法

* `Math.ceil()`向上舍入
* `Math.floor()`向下舍入
* `Math.round()`标准舍入，四舍五入

#### random\(\)方法

`Math.random()`方法返回介于0和1之间的一个随机数，不包括0和1. 从某个正数范围随机选择一个值：

```text
var value=Math.floor(Math.random()*可能的值的总数+第一个可能的值);
```

```text
function selectFrom(min,max){
    var choices=max-min+1;
    return Math.floor(Math.random()*choices+min);
}
```

