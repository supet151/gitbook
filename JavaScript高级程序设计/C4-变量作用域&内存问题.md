# C4-变量 作用域&内存问题
## 基本类型和引用类型的值
基本类型指的是简单的数据段，而引用类型指那些可能由多个值构成的对象。
基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中。

基本类型包括：`Undefined`,`Null`,`Boolean`,`Number`,`String`，基本类型按值访问，可以操作保存在变量中的实际类型。

引用类型的值是保存在内存中的对象，JS不允许直接访问内存中的位置。操作对象实际上是操作对象的引用而不是实际对象。
引用类型的值是对象，保存在堆内存中。

### 动态的属性
对于引用类型，可以为其添加、改变和删除其属性和方法。
但是不能给基本的属性类型添加属性，虽然不会导致错误。
### 复制变量值
复制基本类型的值，将原变量的值复制后赋值给新变量。
复制后的基本类型之间相互独立，互不影响。

复制引用类型的值，是复制实际内存中对象的指针，副本指针和原指针指向用一个内存地址。
### 传递参数
**ES中所有函数参数都是按值传递的**。把函数外部的值赋值给函数内部的参数，和把值从一个变量赋值到另一个变量一样。
基本类型值的传递如同基本类型变量复制。
引用类型值的传递，如同引用类型变量的复制。

对于引用类型值：
```
function setName(obj){
	obj.name="john";//这是外部值
	obj=new Object();//这是一个局部变量，函数执行完立刻销毁。
	obj.name="mike";
}
```

可以将ES的参数想象成局部变量。

### 检测类型
`typeof`操作符是确定一个**基本类型变量**是字符串、数值、布尔值、还是undefined的最佳工具

检测引用类型的值用`instanceof`操作符，如果变量是给定引用类型(通过原型链判断)的实例，那么`instanceof`操作符会返回true。
使用`instanceof`操作符检测基本类型的值，该操作符始终返回false，因为基本类型不是对象。

*使用`typeof`检测函数会返回"function"。*
*ESMA-262规定任何在内部实现`call`方法的对象都应该在`typeof`操作符时返回"function"。*

## 执行环境及作用域
执行环境定义了变量或函数有权访问其他的数据，决定了各自的行为，每个执行环境都有一个与之相关联的**变量对象**。环境中定义的所有的变量和函数都保存在这个对象中。
编写的代码无法访问这个对象，但是解析器在处理数据时会在后台使用。

**执行环境分为全局执行环境和函数执行环境。**
全局执行环境是最外围的一个执行环境。在Web浏览器中，全局执行环境被认为是`window`对象，因此所有的全局变量和函数都是作为`window`对象的属性和方法创建的。

某个执行环境会在环境中的代码执行完毕后销毁，保存的数据也会销毁。
全局执行环境直到应用程序退出(关闭网页||浏览器)才会被销毁。

每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出。把控制权返回给之前的执行环境。
### 作用域链
代码在一个环境中执行时，会创建变量对象的一个**作用域链**。
作用域链会保证变量和函数对于作用域的有序访问。
作用域链的最前端始终都是*当前执行的代码所在环境*的变量对象。
如果*这个环境*是函数，则将其**活动对象**作为变量对象。
活动对象在开始时只包括`arguments`对象一个变量。

作用域链中的下一个变量对象来自包含当前环境的外部环境，以此类推直到延续到全局环境。全局执行环境始终是作用域链的最后一个对象。

**标识符解析**是沿着作用域链一级级地搜索标识符的过程。搜索过程从作用域链前端开始，直到搜索到标识符为止，否则将会发生错误。

函数参数也被当做变量对待，**其访问规则和执行环境中的其他变量相同**。
### 延长作用域链
当执行流进入下列任何语句时，作用域链会变得更长：
- try-catch语句的catch块：创建一个新的变量对象，包含被抛出的错误声明的对象。
- with语句：将指定的对象添加到作用域链中

```
function buildUrl(){
	var qs="debug";
	with(location){
		var url=href+qs;
	}
	return url;
}
```
with语句内部定义了名为url的变量，这个变量称为了函数执行环境的一部分，可以作为函数值返回。

### 没有块级作用域
JS没有块级作用域，{}花括号将不算做作用域。
if语句、for语句等内的代码在执行语句执行完成后会将代码块中的变量声明添加到当前的执行环境中。
#### 声明变量
使用var声明的变量将会自动被添加到最接近的环境中。
如果初始化变量时没有声明，该变量将会被自动添加到全局环境中。(严格模式下导致错误)

#### 查询标识符
在某个环境中引用一个标识符时，从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符，如果找到了，则查询停止，变量就绪。最后最远可以查询到全局作用域。
## 垃圾收集
JS将会自动实现内存的回收管理。
### 标记清除
JS中最常用的垃圾收集方式是标记清除，当变量进入环境(在函数中声明等)时，将这个变量标记为*进入环境*。从逻辑上讲，永远不能释放进入环境的变量所占用的内存。在变量离开环境时，则将其标记为*离开环境*。

垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后去掉环境中的变量以及被环境中变量引用的变量的标记。在此之后再加上标记的变量将被视为准备删除的变量。最后垃圾收集器完成内存清除工作，销毁那些带标记的值并且回收他们所占用的内存空间。
### 引用计数
引用计数将会跟踪记录每个值被引用的次数，针对引用类型。

- 声明一个变量并将存储空间的值赋给该变量，值引用加1
- 存储空间的值被赋给另一个变量，值引用加1
- 指向存储空间的变量重新指向其他存储值，值引用减1

当值的引用变为0时，说明该值无法访问，将其内存进行回收，下次运行垃圾收集器时进行释放。

但是循环引用将会影响正常垃圾回收：
```
function problem(){
	var obj1=new Object();
	var obj2=new Object();
	
	obj1.someObj=obj2;
	obj2.anotherobj=obj1;
}
```
obj1与obj2通过各自的属性相互引用；也就是说这两个对象的引用次数都是2。在采用标记清除策略的实现中，在函数执行结束后，两个对象都离开了作用域，就会被回收。
在采用计数策略的实现中，当函数执行完后，ogj1和obj2还将继续存在。函数的多次调用会导致大量内存得不到回收。

如果使用COM(组件对象模型)，即使浏览器使用标记清除策略，JS访问COM依然是基于引用计数策略的。所以依然会存在循环引用的问题。

将DOM和BOM转为真正的JS对象而不是C++实现，可以解决这这个问题。

### 性能问题
垃圾收集器是周期运行的，确定垃圾收集器的时间间隔是一个非常重要的问题。

### 管理内存
分配给Web浏览器的可用内存数量比分配给桌面应用程序少。这样做是出于安全考虑，防止JS网页耗尽系统内存导致系统崩溃。

#### 解除引用
为了占用最少的内存，提高页面的性能，应该为执行中的代码只保存必要的数据，一旦数据不再有用，最好将其值设置为null来释放，**尤其是大多数全局变量和全局对象的属性**。

解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便回收。