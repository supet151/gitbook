#C3- 基本概念
## 语法
### 标识符
标识符就是指变量、函数、属性的名字或者函数的参数。
ES的标识符应该采用驼峰大小写格式，即第一个字母小写，剩下的每个有意义的单词的首字母大写。
如：
- fisrtFun
- myObj


### 注释
```
//单行注释

/*
*多行注释
*/

```

### 严格模式
在严格模式下，ES中一些不确定的行为将会得到处理，对某些不安全的操作也会抛出错误。
要启用严格模式，在脚本顶部添加编译指示：
```
"use strict";
```
在函数内部上方包含该编译指示也可以指定函数在严格模式下执行。

## 变量
ES的变量是松散类型的，可以用来保存任何类型的数据，每个变量仅仅是一个用于保存值的占位符而已。

使用var操作符定义的变量会称为该变量的作用域中的局部变量。
在函数中使用var定义一个变量，那么变量在函数退出后就会被销毁。

省略var操作符的变量会成为全局变量，可以在任何地方调用，**该方法不被推荐**。
*给未经声明的变量赋值在严格模式下会抛出ReferenceError*

## 数据类型
### typeof操作符
typeof操作符检测给定变量的数据类型。
对一个值使用typeof会返回：
- "undefined":未定义
- "boolean":布尔值
- "string":字符串
- "number":数值
- "object":对象或null
- "function"：函数

typeof不是函数，圆括号可以使用或省略。
使用方法：
```
var msg="msg";
alert(typeof msg);
```
### Undefined类型
`Undefined`类型只有一个值，即`undefined`。
未经初始化(var后不初始化)的值默认为`undefined`。

即使对尚未声明的值执行typeof的返回值为`undefined`，
与`undefined`的值和尚未声明的值不同，未声明的值使用时会产生错误。

### Null类型
`Null`类型只有一个值`null`。
`null`从逻辑上表示一个空指针，所以`typeof null`得到`object`。
如果定义的变量准备在将来用于保存对象，应该初始化为`null`。

### Boolean类型
`Boolean`类型只有两种字面值：`true`&`false`。

ES中所有类型的值都有与这两个Boolean值等价的值。

转型函数`Boolean()`将一个值转换为其对应的`Boolean`值。

|数据类型|转换为true的值|转换为false的值|
|---|---|---|
|Boolean|true|false|
|String|非空字符串|空字符串""|
|Number|任何非零数字|0&NaN|
|Object|任何对象|null|
|Undefined|n/a(不适用)|undefined|

### Number
该类型使用IEEE754格式表示整数和浮点数值。
存储各种进制的值：
```
//十进制整数
var inNum=55;
//八进制56
//八进制字面值的第一位必须是0
var Octnum=070;
//十六进制10
var Hexnum=0xA;
```
*八进制字面值在严格模式下无效；*
在进行计算时，所有以八进制和十六进制表示的数值会转换为十进制。
**JS中数值可以被保存为+0 -0，两者相等。**

#### 浮点数值
浮点数值即带有小数点的小数。

ES会不失时机的把浮点值转化为整数值，
如果小数点后没有根任何数字，就会被转化为整数保存。

对于极大极小值，可以使用科学表示法(e表示法)。
浮点数最高精确度为17位小数，但是精度与整数不同，不要试图使用`==`比较浮点数。
#### 数值范围
ES能够表示的最小数值保存在`Number.MIN_VALUES`，在大多数浏览器中，这个值为5e-324；
能够表示的最大的数值保存在`Number.MAX_VALUES`，在大多数浏览器中，这个值为1.80e+308左右(此处并不是精确值)

如果某次计算值结果超过了JS的数值范围，这个数值将会被自动转换为特殊值`Infinity`，这个值是负数，会被转换为`-Infinity`(负无穷)，如果是正数，就会转换为`Infinity`(正无穷)。

如果某次计算值返回了`Infinity`，将无法继续参与下一步运算。
使用`isFinite()`函数可以确认一个数值是不是有穷的，这个函数在参数位于最大值与最小值之间时会返回true。

在`Number.NEGATIVE_INFINITY`和`Number.POSTIVE_INFINITY`中分别存储着`-Infinity`和`Infinity`。

#### NaN
NaN即(Not a Number)是一个特殊的值，用于表示一个本来要返回数值的操作数未返回数值的情况。如ES中任何数值除以0会返回NaN。

**任何涉及NaN的操作都会返回NaN，在多步计算可能导致问题。**
**NaN与任何值都不相等，包括NaN本身**。

函数`isNaN()`接受一个参数，函数会判断这个参数是否“不是数值”，`isNaN()`会首先试图将参数转为数值，任何不能被转为数值的值会导致参数返回true。
`NaN`、数值、数值的字符串形式的参数、Boolean值得到的结果会是true,其他值为false;

*对于对象调用`isNaN()`函数，会首先调用对象的`valueOf()`方法，然后确定该方法返回值是否可以转为数值；如果不能，将会基于这个返回值再调用`toString()`，再测试返回值。*
#### 数值转换
函数`Number()`,`parseInt()`,`parseFloat()`可以把非数值转换为数值。

`Number()`可以用于任何数据类型，另外两个函数用于把字符串转为数值。

##### Number()转换规则
- true->1,false->0
- 数字不变
- null->0
- undefined->NaN
- 字符串
	- 只有数字或者第一个字符为`-`，将其转为十进制数值。（忽略前导零）
	- 包含有效的浮点格式，转为浮点值。（忽略前导零）
	- 包含有效的十六进制格式,"0xf"，将其转为相同大小的十进制数值
	- 字符串为空->0
	- 字符串包含其他字符->NaN
- 对象：首先调用对象的`valueOf()`方法，然后确定该方法返回值是否可以转为数值；如果不能(NaN)，再调用`toString()`，按照前面的规则返回字符串值。

##### parseInt(string,radix)
**在通常情况下，将10作为第二个参数是非常有必要的。**
转换字符串时，看其是否符合数值模式，会忽略字符串前面的空格，直到找到第一个非空字符。
如果第一个字符不是数字或者符号，将会返回NaN，**即，对于空字符串会返回NaN**。
如果第一个字符是数字字符将会继续解析，直到解析完后续字符或者遇到一个非数字字符，此时，非数字字符将会被忽略。
**小数点也会被认为是非数字字符。**
`parseInt()`也能识别十进制、八进制("070")、十六进制数("0xf")。但是ES5在十进制和八进制的识别上存在一定的歧义，所以在任何时候都应该传入radix进制参数。
以十六进制为例，如果规定了radix参数，可以不使用"0x"
```
//before
var num=parseInt("0xAF");
//after
var num1=parseInt("0xAF",16);
var num2=parseInt("AF",16);
//这样会返回NaN
var num3=parseInt("AF");

```
#### parseInt(string)
`parseInt(string)`与`parseInt()`类似，从第一个字符开始解析每个字符直至字符串末尾或者遇到一个无效的浮点数数字字符为止。
字符串中的第一个小数点是有效的，之后的小数点是无效的，后面的字符串将会被忽略。
同时，他也会忽略前导零。
十六进制格式的字符串会被始终转换为0，该函数只解析十进制值，只有一个参数。
如果字符串包含的是一个可以解析为整数的数，该函数会返回整数。

### String类型
String类型用于表示由零或者多个16位Unicode字符组成的字符序列，即字符串。字符串可以由双引号(`"`)或者(`'`)表示，但是开始符与结束符需要对应。
#### 字符字面量
`String`数据类型包含一些特殊的字符字面量，也称为转义序列，用于表示非打印字符或者具有其他用途的字符。
如：
- `\n`换行
- `\t`制表
- `\b`空格
- `\r`回车
- `\f`进纸符，换页符
- `\\`斜杠
- `\'`单引号，在用单引号表示的字符串中使用
- `\"`双引号，在用双引号表示的字符串中使用
- `\xnn`以十六进制代码nn表示的一个字符从`\00`到`\FF`
- `\unnnn`以十六进制代码nnnn表示的一个Unicode字符

一个字符字面量将会被视为一个字符解析。
通过访问字符串length属性获得字符串的长度。这个属性返回的字符数包括16位字符的数目。如果字符串包含双字节字符，length属性可能不会精确返回字符串中的字符数目。
#### 字符串的特点
ES中的字符串是不可变的，要更改某个变量保存的字符串，首先要销毁原来的字符串，再用新的字符串重新填充。


#### 转换为字符串
使用`toString()`，这个方法唯一要做的就是返回相应值得字符串表现，但是`null`和`undefined`没有这个方法。
调用数值的`toString()`可以传递输出数值的基数，默认为十进制。

转型函数`String()`能够将任何类型的值转为字符串，规则为：
- 有`toString()`使用该方法
- `null`->`"null"`
- `undefined`->`"undefined"`

**将某个值转为字符串，也可以使用加号操作符。**
### Object类型
ES中的对象就是一组数据和功能的集合。对象可以通过：
```
var obj=new Object();
var obj1=new Object;//有效，但是不推荐省略圆括号
```
Object类型是它所有实例的基础。
每个Object实例都有：
- Constructor：保存着用于创建当前对象的函数，对于前面的例子，构造函数就是Object()
- hasOwnProperty(propertyName)；用于检查给定的属性在当前对象实例(而不是实例的原型中)中是否存在。参数属性名需要以字符串形式指定
- isPrototypeOf(object)：用于检查传入对象是否是另一个对象的原型。
- propertyIsEnumerable(propertyName):用于检查给定的属性是否能够使用for-in语句枚举，参数以字符串指定。
- toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应。
- toString():返回对象的字符串表示
- valueOf()：返回对象的字符串、数值或布尔值。通常与toString()方法的返回值相同。

## 操作符
### 一元操作符
只能操作一个值的叫做一元操作符。
#### 递增&递减
前置与后置
```
age++;
++age;
count--;
--count;
```

前置操作符会先进行增减操作再进行赋值等操作；
后置操作符会先进行赋值再进行增减操作。

对于不同的类型值的规则：
- 存在有效值的字符串->转换为数字值操作
- 不包含有效值的字符串->变量值为NaN
- false->0
- true->1
- 浮点直接操作
- 对象->valueOf()==NaN?toString():valueOf();
在以上的规则中，所有的值类型都会变成数值类型。

#### 一元加和减
+加号：
在数值前对数值无影响；
在对非数值应用一元加操作符，等同于使用Number()转型函数；
-负号的行为与加号类似

### 位操作符
ES中所有的数值都以IEEE-754 64位格式存储，位操作不直接操作64位值，而是将64位值转为32位整数进行处理，再将结果转为64位。
位数的转换导致对于`NaN`&`Infinity`应用位操作，两个值会被视为0处理。
对于有符号整数，32位前31位表示整数值，第32位标识符号，0为正，1为负。
负数以二进制补码存储。
默认情况下，ES中所有的整数都是有符号整数。对于无符号整数来说，第32位不再表示符号。

对非数值应用位操作符，会先使用Number()转换。

- 按位非(NOT):`~`非操作本质为操作数的负值减1
- 按位与(AND):`&`
- 按位或(OR):`|`
- 按位异或(XOR):`^`
- 左移:`<<`后接操作数，左移以0填补右侧空位
- 有符号右移:`>>`数值向右移动，保留符号位，左侧空位使用符号位的值填充
- 无符号右移:`>>>`所有32位数值向右移动，左侧空位使用0填充。
### 布尔操作符
#### 逻辑非(!)
使用`!`表示，可以应用于ES任何值。
操作数的转换处理规则：
- object->false
- ""->true
- "xx"->false
- 0->true
- 非0->false
- null->true
- NaN->true
- undefined->true

使用两个逻辑非操作符`!!`实际上就会模拟Boolean()的转型函数的行为。
#### 逻辑与(&&)
处理遵循规则：
- 第一个操作数是对象，只返回第二个操作数
- 第二个是object，在第一个操作数的求值结果为true的情况下返回该对象。
- 两个操作数都是对象，返回第二个操作数
- 有一个操作数为null->null
- 有一个操作数为NaN->NaN
- 有一个操作数为undefined->undefined

为短路操作

#### 逻辑或(||)
处理规则与逻辑与相似
- 1st object->1st
- 1st false->2nd
- all obj->1st
- all null->null
- all NaN->NaN
- all undefined->undefined

可以利用逻辑或的行为避免为变量赋null或undefined值；
```
var myObj=1stObj||2ndObj
```
myObj将会被赋予等号后面两个值中的一个，优先赋值1stObj，在前者不包含有效值时赋值后者。

### 乘性操作符
#### 乘法(*)
符合以下规则：
- each NaN->NaN
- Infinity*0->NaN
- Infinity*not0->(-)Infinity
- Infinity*Infinity->Infinity

#### 除法(/)
- each infi->NaN
- infi/infi->NaN
- 0/0->NaN
- not0limit/0->(-)infi
- infi/not0->(-)infi

#### 求模(%)
- infi%limit->NaN
- limit%0->NaN
- infi%infi->NaN
- limit%infi->limit
- 0%any->0

### 加性操作符
#### 加法
- infi+infi=infi
- -infi+-infi=-infi
- infi+-infi=NaN
- +0++0=+0
- -0+-0=-0
- +0+-0=+0
- 两个操作数为字符串，进行拼接
- 有一个操作数为字符串，将另一个转为字符串，再拼接

#### 减法
- each NaN=NaN
- infi-infi=NaN
- -infi--infi=NaN
- infi--infi=infi
- -infi-infi=-infi
- +0-+0=+0
- +0--0=+0
- -0--0=+0

### 关系操作符
- 都是num,执行数值比较
- 都是字符串，比较字符串对应的字符编码值
- each num，另一个转为数值进行数值比较
- each obj，进行转换再比较
- each boolean，先转为数值，再比较
- each NaN,结果为false

字符比较时要注意，比较的值为字符编码值，而大写字母编码都小于小写编码值。

### 相等操作符
#### 相等和不相等
- each boolean,false->0,true->1
- each string each num,string->num
- each obj each !obj,obj.valueOf()

遵循以下规则:
- null==undefined
- null,undefined不能转换
- 有一个NaN,相等操作符返回false不等返回true;NaN!=NaN
- 两个都是对象，比较是不是一个对象，如果指向一个对象，那么返回true.

#### 全等和不全等
为了避免发生转换，推荐使用全等操作

### 赋值操作符
```
num=num+1
//equal
num+=1
```
- *=
- /=
- %=
- +=
- -=
- <<=
- >>=
- >>>=

## 语句
### for-in语句
for-in时一种精准迭代语句，可以用来枚举对象的属性
如果要迭代的对象变量值为null或者undefined，将不会执行循环体。

### label&break&continue
`label`可以在代码中添加标签
break和continue语句用于在循环中精准控制代码执行
break会立即退出循环
continue会执行下一次循环
可以与label连用跳转至标签位置。

建议不使用label跳转，如果使用，应该使用描述性的标签

### with语句
with的作用时将代码的作用域设置到一个特定的对象中。
```
with (expression) statement;
```
定义with可以简化多次编写同一个对象的工作，将语句statement的作用域设置为expression。

*严格模式下不能使用with，会认为是语法错误。*
使用with会造成性能下降，给调试代码造成困难，开发大型应用程序不应该使用with。

### switch语句
switch语句在比较时使用全等操作符，不会发生类型转移。
## 函数
ES中的函数使用function声明，后跟一组参数以及函数体。
```
function functionName(arg0,arg1...){
	statement;
}
```
未指定返回值的函数返回一个特殊的`undefined`值。
严格模式对于函数有限制：
- 不能把函数名和参数命名为eval||arguments;
- 不能出现两个参数同名

### 理解参数
ES不介意函数传递进入的参数个数与类型，在ES内部使用`arguments`来表示参数，
可以在函数体内使用`arguments`兑现来访问参数数组。
`arguments`只是与数组类似，但是并不是Array的实例，但是可以使用方括号([])访问元素，也可以使用length属性获得传递参数的个数。

在ES中，函数的命名只是为了提供便利，但不是必须的。
**ES中所有参数传递的都是值，不可能哦呢个给引用传递参数。**
`arguments`的值永远与对应的命名参数保持同步，这种影响是**单向的**。
修改命名参数不会改变`arguments`，但是修改`arguments`会改变命名参数。

没有传递值的命名参数将会自动被赋予undefined值。

*在严格模式下，重写`arguments`的值会造成语法错误，代码不会正常执行。*

### 没有重载
ES的函数没有签名，其参数是由包含零或多个值的数组来组成的。
没有函数签名，重载是不会实现的。

如果重复定义同名函数，那么将会取最后一次定义的结果。


